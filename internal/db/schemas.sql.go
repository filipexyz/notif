// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schemas.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchema = `-- name: CreateSchema :one
INSERT INTO schemas (id, org_id, project_id, name, topic_pattern, description, tags)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at
`

type CreateSchemaParams struct {
	ID           string      `json:"id"`
	OrgID        string      `json:"org_id"`
	ProjectID    string      `json:"project_id"`
	Name         string      `json:"name"`
	TopicPattern string      `json:"topic_pattern"`
	Description  pgtype.Text `json:"description"`
	Tags         []string    `json:"tags"`
}

func (q *Queries) CreateSchema(ctx context.Context, arg CreateSchemaParams) (Schema, error) {
	row := q.db.QueryRow(ctx, createSchema,
		arg.ID,
		arg.OrgID,
		arg.ProjectID,
		arg.Name,
		arg.TopicPattern,
		arg.Description,
		arg.Tags,
	)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.Name,
		&i.TopicPattern,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSchemaValidation = `-- name: CreateSchemaValidation :one
INSERT INTO schema_validations (id, org_id, project_id, event_id, schema_id, schema_version_id, topic, valid, errors)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, org_id, project_id, event_id, schema_id, schema_version_id, topic, valid, errors, validated_at
`

type CreateSchemaValidationParams struct {
	ID              string      `json:"id"`
	OrgID           string      `json:"org_id"`
	ProjectID       string      `json:"project_id"`
	EventID         pgtype.Text `json:"event_id"`
	SchemaID        pgtype.Text `json:"schema_id"`
	SchemaVersionID pgtype.Text `json:"schema_version_id"`
	Topic           pgtype.Text `json:"topic"`
	Valid           bool        `json:"valid"`
	Errors          []byte      `json:"errors"`
}

func (q *Queries) CreateSchemaValidation(ctx context.Context, arg CreateSchemaValidationParams) (SchemaValidation, error) {
	row := q.db.QueryRow(ctx, createSchemaValidation,
		arg.ID,
		arg.OrgID,
		arg.ProjectID,
		arg.EventID,
		arg.SchemaID,
		arg.SchemaVersionID,
		arg.Topic,
		arg.Valid,
		arg.Errors,
	)
	var i SchemaValidation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.EventID,
		&i.SchemaID,
		&i.SchemaVersionID,
		&i.Topic,
		&i.Valid,
		&i.Errors,
		&i.ValidatedAt,
	)
	return i, err
}

const createSchemaVersion = `-- name: CreateSchemaVersion :one
INSERT INTO schema_versions (id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_at, created_by
`

type CreateSchemaVersionParams struct {
	ID             string      `json:"id"`
	SchemaID       string      `json:"schema_id"`
	Version        string      `json:"version"`
	SchemaJson     []byte      `json:"schema_json"`
	ValidationMode pgtype.Text `json:"validation_mode"`
	OnInvalid      pgtype.Text `json:"on_invalid"`
	Compatibility  pgtype.Text `json:"compatibility"`
	Examples       []byte      `json:"examples"`
	Fingerprint    pgtype.Text `json:"fingerprint"`
	IsLatest       pgtype.Bool `json:"is_latest"`
	CreatedBy      pgtype.Text `json:"created_by"`
}

func (q *Queries) CreateSchemaVersion(ctx context.Context, arg CreateSchemaVersionParams) (SchemaVersion, error) {
	row := q.db.QueryRow(ctx, createSchemaVersion,
		arg.ID,
		arg.SchemaID,
		arg.Version,
		arg.SchemaJson,
		arg.ValidationMode,
		arg.OnInvalid,
		arg.Compatibility,
		arg.Examples,
		arg.Fingerprint,
		arg.IsLatest,
		arg.CreatedBy,
	)
	var i SchemaVersion
	err := row.Scan(
		&i.ID,
		&i.SchemaID,
		&i.Version,
		&i.SchemaJson,
		&i.ValidationMode,
		&i.OnInvalid,
		&i.Compatibility,
		&i.Examples,
		&i.Fingerprint,
		&i.IsLatest,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteSchema = `-- name: DeleteSchema :exec
DELETE FROM schemas WHERE id = $1
`

func (q *Queries) DeleteSchema(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSchema, id)
	return err
}

const deleteSchemaVersion = `-- name: DeleteSchemaVersion :exec
DELETE FROM schema_versions WHERE id = $1
`

func (q *Queries) DeleteSchemaVersion(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSchemaVersion, id)
	return err
}

const getLatestSchemaVersion = `-- name: GetLatestSchemaVersion :one
SELECT id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_at, created_by FROM schema_versions
WHERE schema_id = $1 AND is_latest = true
`

func (q *Queries) GetLatestSchemaVersion(ctx context.Context, schemaID string) (SchemaVersion, error) {
	row := q.db.QueryRow(ctx, getLatestSchemaVersion, schemaID)
	var i SchemaVersion
	err := row.Scan(
		&i.ID,
		&i.SchemaID,
		&i.Version,
		&i.SchemaJson,
		&i.ValidationMode,
		&i.OnInvalid,
		&i.Compatibility,
		&i.Examples,
		&i.Fingerprint,
		&i.IsLatest,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getSchema = `-- name: GetSchema :one
SELECT id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at FROM schemas WHERE id = $1
`

func (q *Queries) GetSchema(ctx context.Context, id string) (Schema, error) {
	row := q.db.QueryRow(ctx, getSchema, id)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.Name,
		&i.TopicPattern,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSchemaByName = `-- name: GetSchemaByName :one
SELECT id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at FROM schemas WHERE project_id = $1 AND name = $2
`

type GetSchemaByNameParams struct {
	ProjectID string `json:"project_id"`
	Name      string `json:"name"`
}

func (q *Queries) GetSchemaByName(ctx context.Context, arg GetSchemaByNameParams) (Schema, error) {
	row := q.db.QueryRow(ctx, getSchemaByName, arg.ProjectID, arg.Name)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.Name,
		&i.TopicPattern,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSchemaForTopic = `-- name: GetSchemaForTopic :one
SELECT s.id, s.org_id, s.project_id, s.name, s.topic_pattern, s.description, s.tags, s.created_at, s.updated_at FROM schemas s
WHERE s.project_id = $1
  AND ($2::text LIKE REPLACE(REPLACE(s.topic_pattern, '.', '\.'), '*', '%')
       OR s.topic_pattern = $2::text)
ORDER BY LENGTH(s.topic_pattern) DESC
LIMIT 1
`

type GetSchemaForTopicParams struct {
	ProjectID string `json:"project_id"`
	Topic     string `json:"topic"`
}

func (q *Queries) GetSchemaForTopic(ctx context.Context, arg GetSchemaForTopicParams) (Schema, error) {
	row := q.db.QueryRow(ctx, getSchemaForTopic, arg.ProjectID, arg.Topic)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.Name,
		&i.TopicPattern,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSchemaValidation = `-- name: GetSchemaValidation :one
SELECT id, org_id, project_id, event_id, schema_id, schema_version_id, topic, valid, errors, validated_at FROM schema_validations WHERE id = $1
`

func (q *Queries) GetSchemaValidation(ctx context.Context, id string) (SchemaValidation, error) {
	row := q.db.QueryRow(ctx, getSchemaValidation, id)
	var i SchemaValidation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.EventID,
		&i.SchemaID,
		&i.SchemaVersionID,
		&i.Topic,
		&i.Valid,
		&i.Errors,
		&i.ValidatedAt,
	)
	return i, err
}

const getSchemaVersion = `-- name: GetSchemaVersion :one
SELECT id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_at, created_by FROM schema_versions WHERE id = $1
`

func (q *Queries) GetSchemaVersion(ctx context.Context, id string) (SchemaVersion, error) {
	row := q.db.QueryRow(ctx, getSchemaVersion, id)
	var i SchemaVersion
	err := row.Scan(
		&i.ID,
		&i.SchemaID,
		&i.Version,
		&i.SchemaJson,
		&i.ValidationMode,
		&i.OnInvalid,
		&i.Compatibility,
		&i.Examples,
		&i.Fingerprint,
		&i.IsLatest,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getSchemaVersionByVersion = `-- name: GetSchemaVersionByVersion :one
SELECT id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_at, created_by FROM schema_versions
WHERE schema_id = $1 AND version = $2
`

type GetSchemaVersionByVersionParams struct {
	SchemaID string `json:"schema_id"`
	Version  string `json:"version"`
}

func (q *Queries) GetSchemaVersionByVersion(ctx context.Context, arg GetSchemaVersionByVersionParams) (SchemaVersion, error) {
	row := q.db.QueryRow(ctx, getSchemaVersionByVersion, arg.SchemaID, arg.Version)
	var i SchemaVersion
	err := row.Scan(
		&i.ID,
		&i.SchemaID,
		&i.Version,
		&i.SchemaJson,
		&i.ValidationMode,
		&i.OnInvalid,
		&i.Compatibility,
		&i.Examples,
		&i.Fingerprint,
		&i.IsLatest,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getValidationStats = `-- name: GetValidationStats :one
SELECT
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE valid = true) as valid_count,
    COUNT(*) FILTER (WHERE valid = false) as invalid_count
FROM schema_validations
WHERE project_id = $1
  AND validated_at > NOW() - INTERVAL '24 hours'
`

type GetValidationStatsRow struct {
	Total        int64 `json:"total"`
	ValidCount   int64 `json:"valid_count"`
	InvalidCount int64 `json:"invalid_count"`
}

func (q *Queries) GetValidationStats(ctx context.Context, projectID string) (GetValidationStatsRow, error) {
	row := q.db.QueryRow(ctx, getValidationStats, projectID)
	var i GetValidationStatsRow
	err := row.Scan(&i.Total, &i.ValidCount, &i.InvalidCount)
	return i, err
}

const getValidationStatsBySchema = `-- name: GetValidationStatsBySchema :one
SELECT
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE valid = true) as valid_count,
    COUNT(*) FILTER (WHERE valid = false) as invalid_count
FROM schema_validations
WHERE schema_id = $1
  AND validated_at > NOW() - INTERVAL '24 hours'
`

type GetValidationStatsBySchemaRow struct {
	Total        int64 `json:"total"`
	ValidCount   int64 `json:"valid_count"`
	InvalidCount int64 `json:"invalid_count"`
}

func (q *Queries) GetValidationStatsBySchema(ctx context.Context, schemaID pgtype.Text) (GetValidationStatsBySchemaRow, error) {
	row := q.db.QueryRow(ctx, getValidationStatsBySchema, schemaID)
	var i GetValidationStatsBySchemaRow
	err := row.Scan(&i.Total, &i.ValidCount, &i.InvalidCount)
	return i, err
}

const listSchemaValidations = `-- name: ListSchemaValidations :many
SELECT id, org_id, project_id, event_id, schema_id, schema_version_id, topic, valid, errors, validated_at FROM schema_validations
WHERE project_id = $1
ORDER BY validated_at DESC
LIMIT $2 OFFSET $3
`

type ListSchemaValidationsParams struct {
	ProjectID string `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListSchemaValidations(ctx context.Context, arg ListSchemaValidationsParams) ([]SchemaValidation, error) {
	rows, err := q.db.Query(ctx, listSchemaValidations, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaValidation{}
	for rows.Next() {
		var i SchemaValidation
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ProjectID,
			&i.EventID,
			&i.SchemaID,
			&i.SchemaVersionID,
			&i.Topic,
			&i.Valid,
			&i.Errors,
			&i.ValidatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemaValidationsBySchema = `-- name: ListSchemaValidationsBySchema :many
SELECT id, org_id, project_id, event_id, schema_id, schema_version_id, topic, valid, errors, validated_at FROM schema_validations
WHERE schema_id = $1
ORDER BY validated_at DESC
LIMIT $2 OFFSET $3
`

type ListSchemaValidationsBySchemaParams struct {
	SchemaID pgtype.Text `json:"schema_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListSchemaValidationsBySchema(ctx context.Context, arg ListSchemaValidationsBySchemaParams) ([]SchemaValidation, error) {
	rows, err := q.db.Query(ctx, listSchemaValidationsBySchema, arg.SchemaID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaValidation{}
	for rows.Next() {
		var i SchemaValidation
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ProjectID,
			&i.EventID,
			&i.SchemaID,
			&i.SchemaVersionID,
			&i.Topic,
			&i.Valid,
			&i.Errors,
			&i.ValidatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemaVersions = `-- name: ListSchemaVersions :many
SELECT id, schema_id, version, schema_json, validation_mode, on_invalid, compatibility, examples, fingerprint, is_latest, created_at, created_by FROM schema_versions
WHERE schema_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSchemaVersions(ctx context.Context, schemaID string) ([]SchemaVersion, error) {
	rows, err := q.db.Query(ctx, listSchemaVersions, schemaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaVersion{}
	for rows.Next() {
		var i SchemaVersion
		if err := rows.Scan(
			&i.ID,
			&i.SchemaID,
			&i.Version,
			&i.SchemaJson,
			&i.ValidationMode,
			&i.OnInvalid,
			&i.Compatibility,
			&i.Examples,
			&i.Fingerprint,
			&i.IsLatest,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemas = `-- name: ListSchemas :many
SELECT id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at FROM schemas
WHERE project_id = $1
ORDER BY name ASC
`

func (q *Queries) ListSchemas(ctx context.Context, projectID string) ([]Schema, error) {
	rows, err := q.db.Query(ctx, listSchemas, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schema{}
	for rows.Next() {
		var i Schema
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ProjectID,
			&i.Name,
			&i.TopicPattern,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemasByTag = `-- name: ListSchemasByTag :many
SELECT id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at FROM schemas
WHERE project_id = $1 AND $2 = ANY(tags)
ORDER BY name ASC
`

type ListSchemasByTagParams struct {
	ProjectID string   `json:"project_id"`
	Tags      []string `json:"tags"`
}

func (q *Queries) ListSchemasByTag(ctx context.Context, arg ListSchemasByTagParams) ([]Schema, error) {
	rows, err := q.db.Query(ctx, listSchemasByTag, arg.ProjectID, arg.Tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Schema{}
	for rows.Next() {
		var i Schema
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ProjectID,
			&i.Name,
			&i.TopicPattern,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSchemaVersionLatest = `-- name: SetSchemaVersionLatest :exec
UPDATE schema_versions
SET is_latest = (id = $2)
WHERE schema_id = $1
`

type SetSchemaVersionLatestParams struct {
	SchemaID string `json:"schema_id"`
	ID       string `json:"id"`
}

func (q *Queries) SetSchemaVersionLatest(ctx context.Context, arg SetSchemaVersionLatestParams) error {
	_, err := q.db.Exec(ctx, setSchemaVersionLatest, arg.SchemaID, arg.ID)
	return err
}

const updateSchema = `-- name: UpdateSchema :one
UPDATE schemas
SET topic_pattern = $2, description = $3, tags = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, org_id, project_id, name, topic_pattern, description, tags, created_at, updated_at
`

type UpdateSchemaParams struct {
	ID           string      `json:"id"`
	TopicPattern string      `json:"topic_pattern"`
	Description  pgtype.Text `json:"description"`
	Tags         []string    `json:"tags"`
}

func (q *Queries) UpdateSchema(ctx context.Context, arg UpdateSchemaParams) (Schema, error) {
	row := q.db.QueryRow(ctx, updateSchema,
		arg.ID,
		arg.TopicPattern,
		arg.Description,
		arg.Tags,
	)
	var i Schema
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ProjectID,
		&i.Name,
		&i.TopicPattern,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
