// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (org_id, url, topics, secret)
VALUES ($1, $2, $3, $4)
RETURNING id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id
`

type CreateWebhookParams struct {
	OrgID  pgtype.Text `json:"org_id"`
	Url    string      `json:"url"`
	Topics []string    `json:"topics"`
	Secret string      `json:"secret"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, createWebhook,
		arg.OrgID,
		arg.Url,
		arg.Topics,
		arg.Secret,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.ApiKeyID,
		&i.Url,
		&i.Topics,
		&i.Secret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
	)
	return i, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (webhook_id, event_id, topic, status)
VALUES ($1, $2, $3, 'pending')
RETURNING id, webhook_id, event_id, topic, status, attempt, response_status, response_body, error, created_at, delivered_at
`

type CreateWebhookDeliveryParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	EventID   string      `json:"event_id"`
	Topic     string      `json:"topic"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery, arg.WebhookID, arg.EventID, arg.Topic)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EventID,
		&i.Topic,
		&i.Status,
		&i.Attempt,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.Error,
		&i.CreatedAt,
		&i.DeliveredAt,
	)
	return i, err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE FROM webhooks WHERE id = $1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhook, id)
	return err
}

const getDeliveriesByEventID = `-- name: GetDeliveriesByEventID :many
SELECT wd.id, wd.webhook_id, wd.event_id, wd.topic, wd.status, wd.attempt, wd.response_status, wd.response_body, wd.error, wd.created_at, wd.delivered_at, w.url as webhook_url
FROM webhook_deliveries wd
JOIN webhooks w ON w.id = wd.webhook_id
WHERE wd.event_id = $1
ORDER BY wd.created_at DESC
`

type GetDeliveriesByEventIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	WebhookID      pgtype.UUID        `json:"webhook_id"`
	EventID        string             `json:"event_id"`
	Topic          string             `json:"topic"`
	Status         string             `json:"status"`
	Attempt        int32              `json:"attempt"`
	ResponseStatus pgtype.Int4        `json:"response_status"`
	ResponseBody   pgtype.Text        `json:"response_body"`
	Error          pgtype.Text        `json:"error"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	WebhookUrl     string             `json:"webhook_url"`
}

func (q *Queries) GetDeliveriesByEventID(ctx context.Context, eventID string) ([]GetDeliveriesByEventIDRow, error) {
	rows, err := q.db.Query(ctx, getDeliveriesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeliveriesByEventIDRow{}
	for rows.Next() {
		var i GetDeliveriesByEventIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventID,
			&i.Topic,
			&i.Status,
			&i.Attempt,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.Error,
			&i.CreatedAt,
			&i.DeliveredAt,
			&i.WebhookUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledWebhooks = `-- name: GetEnabledWebhooks :many
SELECT id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id FROM webhooks
WHERE enabled = true
ORDER BY created_at
`

func (q *Queries) GetEnabledWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, getEnabledWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.Url,
			&i.Topics,
			&i.Secret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledWebhooksByOrg = `-- name: GetEnabledWebhooksByOrg :many
SELECT id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id FROM webhooks
WHERE org_id = $1 AND enabled = true
ORDER BY created_at DESC
`

func (q *Queries) GetEnabledWebhooksByOrg(ctx context.Context, orgID pgtype.Text) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, getEnabledWebhooksByOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.Url,
			&i.Topics,
			&i.Secret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingDeliveries = `-- name: GetPendingDeliveries :many
SELECT wd.id, wd.webhook_id, wd.event_id, wd.topic, wd.status, wd.attempt, wd.response_status, wd.response_body, wd.error, wd.created_at, wd.delivered_at, w.url, w.secret
FROM webhook_deliveries wd
JOIN webhooks w ON w.id = wd.webhook_id
WHERE wd.status = 'pending' AND w.enabled = true
ORDER BY wd.created_at
LIMIT $1
`

type GetPendingDeliveriesRow struct {
	ID             pgtype.UUID        `json:"id"`
	WebhookID      pgtype.UUID        `json:"webhook_id"`
	EventID        string             `json:"event_id"`
	Topic          string             `json:"topic"`
	Status         string             `json:"status"`
	Attempt        int32              `json:"attempt"`
	ResponseStatus pgtype.Int4        `json:"response_status"`
	ResponseBody   pgtype.Text        `json:"response_body"`
	Error          pgtype.Text        `json:"error"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
	Url            string             `json:"url"`
	Secret         string             `json:"secret"`
}

func (q *Queries) GetPendingDeliveries(ctx context.Context, limit int32) ([]GetPendingDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, getPendingDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingDeliveriesRow{}
	for rows.Next() {
		var i GetPendingDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventID,
			&i.Topic,
			&i.Status,
			&i.Attempt,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.Error,
			&i.CreatedAt,
			&i.DeliveredAt,
			&i.Url,
			&i.Secret,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id FROM webhooks WHERE id = $1
`

func (q *Queries) GetWebhook(ctx context.Context, id pgtype.UUID) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.ApiKeyID,
		&i.Url,
		&i.Topics,
		&i.Secret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
	)
	return i, err
}

const getWebhookDeliveries = `-- name: GetWebhookDeliveries :many
SELECT id, webhook_id, event_id, topic, status, attempt, response_status, response_body, error, created_at, delivered_at FROM webhook_deliveries
WHERE webhook_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetWebhookDeliveriesParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetWebhookDeliveries(ctx context.Context, arg GetWebhookDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getWebhookDeliveries, arg.WebhookID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventID,
			&i.Topic,
			&i.Status,
			&i.Attempt,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.Error,
			&i.CreatedAt,
			&i.DeliveredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhooksByAPIKey = `-- name: GetWebhooksByAPIKey :many
SELECT id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id FROM webhooks
WHERE api_key_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetWebhooksByAPIKey(ctx context.Context, apiKeyID pgtype.UUID) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, getWebhooksByAPIKey, apiKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.Url,
			&i.Topics,
			&i.Secret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhooksByOrg = `-- name: GetWebhooksByOrg :many
SELECT id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id FROM webhooks
WHERE org_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetWebhooksByOrg(ctx context.Context, orgID pgtype.Text) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, getWebhooksByOrg, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.ApiKeyID,
			&i.Url,
			&i.Topics,
			&i.Secret,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks
SET url = $2, topics = $3, enabled = $4, updated_at = NOW()
WHERE id = $1
RETURNING id, api_key_id, url, topics, secret, enabled, created_at, updated_at, org_id
`

type UpdateWebhookParams struct {
	ID      pgtype.UUID `json:"id"`
	Url     string      `json:"url"`
	Topics  []string    `json:"topics"`
	Enabled bool        `json:"enabled"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, updateWebhook,
		arg.ID,
		arg.Url,
		arg.Topics,
		arg.Enabled,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.ApiKeyID,
		&i.Url,
		&i.Topics,
		&i.Secret,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrgID,
	)
	return i, err
}

const updateWebhookDelivery = `-- name: UpdateWebhookDelivery :exec
UPDATE webhook_deliveries
SET status = $2, attempt = $3, response_status = $4, response_body = $5, error = $6, delivered_at = $7
WHERE id = $1
`

type UpdateWebhookDeliveryParams struct {
	ID             pgtype.UUID        `json:"id"`
	Status         string             `json:"status"`
	Attempt        int32              `json:"attempt"`
	ResponseStatus pgtype.Int4        `json:"response_status"`
	ResponseBody   pgtype.Text        `json:"response_body"`
	Error          pgtype.Text        `json:"error"`
	DeliveredAt    pgtype.Timestamptz `json:"delivered_at"`
}

func (q *Queries) UpdateWebhookDelivery(ctx context.Context, arg UpdateWebhookDeliveryParams) error {
	_, err := q.db.Exec(ctx, updateWebhookDelivery,
		arg.ID,
		arg.Status,
		arg.Attempt,
		arg.ResponseStatus,
		arg.ResponseBody,
		arg.Error,
		arg.DeliveredAt,
	)
	return err
}
