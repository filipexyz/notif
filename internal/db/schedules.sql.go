// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: schedules.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelScheduledEvent = `-- name: CancelScheduledEvent :execrows
UPDATE scheduled_events
SET status = 'cancelled'
WHERE id = $1 AND org_id = $2 AND status = 'pending'
`

type CancelScheduledEventParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) CancelScheduledEvent(ctx context.Context, arg CancelScheduledEventParams) (int64, error) {
	result, err := q.db.Exec(ctx, cancelScheduledEvent, arg.ID, arg.OrgID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countScheduledEventsByStatus = `-- name: CountScheduledEventsByStatus :one
SELECT
    COUNT(*) FILTER (WHERE status = 'pending') as pending,
    COUNT(*) FILTER (WHERE status = 'completed') as completed,
    COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled,
    COUNT(*) FILTER (WHERE status = 'failed') as failed
FROM scheduled_events
WHERE org_id = $1
`

type CountScheduledEventsByStatusRow struct {
	Pending   int64 `json:"pending"`
	Completed int64 `json:"completed"`
	Cancelled int64 `json:"cancelled"`
	Failed    int64 `json:"failed"`
}

func (q *Queries) CountScheduledEventsByStatus(ctx context.Context, orgID string) (CountScheduledEventsByStatusRow, error) {
	row := q.db.QueryRow(ctx, countScheduledEventsByStatus, orgID)
	var i CountScheduledEventsByStatusRow
	err := row.Scan(
		&i.Pending,
		&i.Completed,
		&i.Cancelled,
		&i.Failed,
	)
	return i, err
}

const createScheduledEvent = `-- name: CreateScheduledEvent :one
INSERT INTO scheduled_events (id, org_id, topic, data, scheduled_for, api_key_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at
`

type CreateScheduledEventParams struct {
	ID           string             `json:"id"`
	OrgID        string             `json:"org_id"`
	Topic        string             `json:"topic"`
	Data         []byte             `json:"data"`
	ScheduledFor pgtype.Timestamptz `json:"scheduled_for"`
	ApiKeyID     pgtype.UUID        `json:"api_key_id"`
}

func (q *Queries) CreateScheduledEvent(ctx context.Context, arg CreateScheduledEventParams) (ScheduledEvent, error) {
	row := q.db.QueryRow(ctx, createScheduledEvent,
		arg.ID,
		arg.OrgID,
		arg.Topic,
		arg.Data,
		arg.ScheduledFor,
		arg.ApiKeyID,
	)
	var i ScheduledEvent
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Topic,
		&i.Data,
		&i.ScheduledFor,
		&i.Status,
		&i.ApiKeyID,
		&i.Error,
		&i.CreatedAt,
		&i.ExecutedAt,
	)
	return i, err
}

const getPendingScheduledEvents = `-- name: GetPendingScheduledEvents :many
SELECT id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at FROM scheduled_events
WHERE scheduled_for <= NOW() AND status = 'pending'
ORDER BY scheduled_for ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetPendingScheduledEvents(ctx context.Context, limit int32) ([]ScheduledEvent, error) {
	rows, err := q.db.Query(ctx, getPendingScheduledEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledEvent{}
	for rows.Next() {
		var i ScheduledEvent
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Topic,
			&i.Data,
			&i.ScheduledFor,
			&i.Status,
			&i.ApiKeyID,
			&i.Error,
			&i.CreatedAt,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledEvent = `-- name: GetScheduledEvent :one
SELECT id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at FROM scheduled_events WHERE id = $1 AND org_id = $2
`

type GetScheduledEventParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) GetScheduledEvent(ctx context.Context, arg GetScheduledEventParams) (ScheduledEvent, error) {
	row := q.db.QueryRow(ctx, getScheduledEvent, arg.ID, arg.OrgID)
	var i ScheduledEvent
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Topic,
		&i.Data,
		&i.ScheduledFor,
		&i.Status,
		&i.ApiKeyID,
		&i.Error,
		&i.CreatedAt,
		&i.ExecutedAt,
	)
	return i, err
}

const getScheduledEventForExecution = `-- name: GetScheduledEventForExecution :one
SELECT id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at FROM scheduled_events
WHERE id = $1 AND org_id = $2 AND status = 'pending'
FOR UPDATE SKIP LOCKED
`

type GetScheduledEventForExecutionParams struct {
	ID    string `json:"id"`
	OrgID string `json:"org_id"`
}

func (q *Queries) GetScheduledEventForExecution(ctx context.Context, arg GetScheduledEventForExecutionParams) (ScheduledEvent, error) {
	row := q.db.QueryRow(ctx, getScheduledEventForExecution, arg.ID, arg.OrgID)
	var i ScheduledEvent
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Topic,
		&i.Data,
		&i.ScheduledFor,
		&i.Status,
		&i.ApiKeyID,
		&i.Error,
		&i.CreatedAt,
		&i.ExecutedAt,
	)
	return i, err
}

const listScheduledEvents = `-- name: ListScheduledEvents :many
SELECT id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at FROM scheduled_events
WHERE org_id = $1
ORDER BY scheduled_for DESC
LIMIT $2 OFFSET $3
`

type ListScheduledEventsParams struct {
	OrgID  string `json:"org_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListScheduledEvents(ctx context.Context, arg ListScheduledEventsParams) ([]ScheduledEvent, error) {
	rows, err := q.db.Query(ctx, listScheduledEvents, arg.OrgID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledEvent{}
	for rows.Next() {
		var i ScheduledEvent
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Topic,
			&i.Data,
			&i.ScheduledFor,
			&i.Status,
			&i.ApiKeyID,
			&i.Error,
			&i.CreatedAt,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledEventsByStatus = `-- name: ListScheduledEventsByStatus :many
SELECT id, org_id, topic, data, scheduled_for, status, api_key_id, error, created_at, executed_at FROM scheduled_events
WHERE org_id = $1 AND status = $2
ORDER BY scheduled_for DESC
LIMIT $3 OFFSET $4
`

type ListScheduledEventsByStatusParams struct {
	OrgID  string `json:"org_id"`
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListScheduledEventsByStatus(ctx context.Context, arg ListScheduledEventsByStatusParams) ([]ScheduledEvent, error) {
	rows, err := q.db.Query(ctx, listScheduledEventsByStatus,
		arg.OrgID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledEvent{}
	for rows.Next() {
		var i ScheduledEvent
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Topic,
			&i.Data,
			&i.ScheduledFor,
			&i.Status,
			&i.ApiKeyID,
			&i.Error,
			&i.CreatedAt,
			&i.ExecutedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheduledEventStatus = `-- name: UpdateScheduledEventStatus :exec
UPDATE scheduled_events
SET status = $1::text,
    executed_at = CASE WHEN $1::text = 'completed' THEN NOW() ELSE executed_at END,
    error = $2
WHERE id = $3
`

type UpdateScheduledEventStatusParams struct {
	Status string      `json:"status"`
	Error  pgtype.Text `json:"error"`
	ID     string      `json:"id"`
}

func (q *Queries) UpdateScheduledEventStatus(ctx context.Context, arg UpdateScheduledEventStatusParams) error {
	_, err := q.db.Exec(ctx, updateScheduledEventStatus, arg.Status, arg.Error, arg.ID)
	return err
}
