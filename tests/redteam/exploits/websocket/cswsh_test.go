//go:build redteam

package websocket

import (
	"net/http"
	"testing"
	"time"

	"github.com/gorilla/websocket"

	"github.com/filipexyz/notif/tests/redteam/exploits"
)

// TestCSWSH tests Cross-Site WebSocket Hijacking vulnerability
// NOTIF-001: WebSocket accepts connections from any origin
func TestCSWSH(t *testing.T) {
	cfg := exploits.LoadConfig()

	maliciousOrigins := []string{
		"https://attacker.com",
		"https://evil.example.com",
		"null", // file:// URLs send "null" origin
		"",     // No origin header
	}

	for _, origin := range maliciousOrigins {
		t.Run("Origin_"+origin, func(t *testing.T) {
			dialer := websocket.Dialer{
				HandshakeTimeout: 5 * time.Second,
			}

			headers := http.Header{}
			if origin != "" {
				headers.Set("Origin", origin)
			}

			conn, resp, err := dialer.Dial(cfg.WSTargetURL, headers)

			// If connection succeeds with malicious origin, vulnerability confirmed
			if err == nil {
				t.Errorf("VULNERABLE: WebSocket accepted connection from origin: %q", origin)
				conn.Close()
				return
			}

			// Expected: 403 Forbidden for invalid origins
			if resp != nil && resp.StatusCode != http.StatusForbidden {
				t.Errorf("Expected 403 Forbidden, got %d for origin: %q", resp.StatusCode, origin)
			}
		})
	}
}

// TestWebSocketAuthBypass tests if WebSocket requires authentication
func TestWebSocketAuthBypass(t *testing.T) {
	cfg := exploits.LoadConfig()

	dialer := websocket.Dialer{
		HandshakeTimeout: 5 * time.Second,
	}

	// Try connecting without any auth
	conn, _, err := dialer.Dial(cfg.WSTargetURL, nil)
	if err == nil {
		// Check if we can receive messages
		conn.SetReadDeadline(time.Now().Add(2 * time.Second))
		_, _, readErr := conn.ReadMessage()

		if readErr == nil {
			t.Error("VULNERABLE: WebSocket allows unauthenticated connections and message reception")
		}
		conn.Close()
	}
}

// TestWebSocketMessageInjection tests if malicious messages can be sent
func TestWebSocketMessageInjection(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	dialer := websocket.Dialer{
		HandshakeTimeout: 5 * time.Second,
	}

	headers := http.Header{}
	headers.Set("Authorization", "Bearer "+cfg.APIKey)

	conn, _, err := dialer.Dial(cfg.WSTargetURL, headers)
	if err != nil {
		t.Fatalf("Failed to connect: %v", err)
	}
	defer conn.Close()

	// Try to send various malicious payloads
	maliciousPayloads := [][]byte{
		[]byte(`{"type":"subscribe","topics":["*"]}`),                      // Wildcard subscription
		[]byte(`{"type":"subscribe","topics":["../../../etc/passwd"]}`),   // Path traversal
		[]byte(`{"type":"admin","action":"delete_all"}`),                  // Fake admin command
		[]byte{0x00, 0x01, 0x02, 0x03},                                    // Binary garbage
		make([]byte, 1024*1024),                                           // 1MB payload
	}

	for i, payload := range maliciousPayloads {
		err := conn.WriteMessage(websocket.TextMessage, payload)
		if err != nil {
			t.Logf("Payload %d rejected (good): %v", i, err)
		} else {
			t.Logf("Payload %d accepted - check server behavior", i)
		}
	}
}

// TestWebSocketConnectionFlood tests DoS via connection exhaustion
func TestWebSocketConnectionFlood(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping DoS test in short mode")
	}

	cfg := exploits.LoadConfig()

	const maxConnections = 100
	connections := make([]*websocket.Conn, 0, maxConnections)

	dialer := websocket.Dialer{
		HandshakeTimeout: 2 * time.Second,
	}

	for i := 0; i < maxConnections; i++ {
		conn, _, err := dialer.Dial(cfg.WSTargetURL, nil)
		if err != nil {
			t.Logf("Connection limit reached at %d connections", i)
			break
		}
		connections = append(connections, conn)
	}

	if len(connections) == maxConnections {
		t.Errorf("VULNERABLE: Server accepted all %d connections without limit", maxConnections)
	}

	// Cleanup
	for _, conn := range connections {
		conn.Close()
	}
}
