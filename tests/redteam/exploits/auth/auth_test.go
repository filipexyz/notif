//go:build redteam

package auth

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/filipexyz/notif/tests/redteam/exploits"
)

// TestNoAuthAccess tests endpoints without authentication
func TestNoAuthAccess(t *testing.T) {
	cfg := exploits.LoadConfig()

	// Endpoints that should require auth
	protectedEndpoints := []struct {
		method string
		path   string
	}{
		{"POST", "/api/v1/emit"},
		{"GET", "/api/v1/events"},
		{"GET", "/api/v1/events/stats"},
		{"POST", "/api/v1/webhooks"},
		{"GET", "/api/v1/webhooks"},
		{"GET", "/api/v1/dlq"},
		{"GET", "/api/v1/stats/overview"},
		{"POST", "/api/v1/api-keys"},
		{"GET", "/api/v1/api-keys"},
		{"POST", "/api/v1/schedules"},
		{"GET", "/api/v1/schedules"},
	}

	client := &http.Client{Timeout: 5 * time.Second}

	for _, ep := range protectedEndpoints {
		t.Run(ep.method+"_"+ep.path, func(t *testing.T) {
			var body io.Reader
			if ep.method == "POST" {
				body = bytes.NewReader([]byte(`{}`))
			}

			req, _ := http.NewRequest(ep.method, cfg.TargetURL+ep.path, body)
			req.Header.Set("Content-Type", "application/json")
			// No auth header!

			resp, err := client.Do(req)
			if err != nil {
				t.Logf("Request failed: %v", err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != http.StatusUnauthorized && resp.StatusCode != http.StatusForbidden {
				t.Errorf("VULNERABLE: %s %s accessible without auth (status %d)", ep.method, ep.path, resp.StatusCode)
			}
		})
	}
}

// TestInvalidAPIKeyFormats tests API key validation
func TestInvalidAPIKeyFormats(t *testing.T) {
	cfg := exploits.LoadConfig()

	invalidKeys := []string{
		"",                               // Empty
		"invalid",                        // Wrong prefix
		"nsh_",                           // Prefix only
		"nsh_short",                      // Too short
		"nsh_" + strings.Repeat("a", 27), // 27 chars (need 28)
		"nsh_" + strings.Repeat("a", 29), // 29 chars (need 28)
		"NSH_" + strings.Repeat("a", 28), // Wrong case prefix
		"nsh_" + strings.Repeat("!", 28), // Invalid characters
		"Bearer nsh_test",                // Bearer prefix included
		"nsh_aaaaaaaaaaaaaaaaaaaaaaaaaaaa\x00", // Null byte injection
	}

	client := &http.Client{Timeout: 5 * time.Second}

	for _, key := range invalidKeys {
		t.Run(truncate(key, 20), func(t *testing.T) {
			req, _ := http.NewRequest("GET", cfg.TargetURL+"/api/v1/events", nil)
			req.Header.Set("Authorization", "Bearer "+key)

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != http.StatusUnauthorized && resp.StatusCode != http.StatusForbidden {
				t.Errorf("VULNERABLE: Invalid API key accepted: %q (status %d)", key, resp.StatusCode)
			}
		})
	}
}

// TestAPIKeyBruteForce tests if brute force protection exists
func TestAPIKeyBruteForce(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping brute force test in short mode")
	}

	cfg := exploits.LoadConfig()

	client := &http.Client{Timeout: 5 * time.Second}

	// Try many invalid keys rapidly
	const attempts = 100
	blocked := 0

	for i := 0; i < attempts; i++ {
		// Generate fake key
		fakeKey := "nsh_" + strings.Repeat("x", 28)

		req, _ := http.NewRequest("GET", cfg.TargetURL+"/api/v1/events", nil)
		req.Header.Set("Authorization", "Bearer "+fakeKey)

		resp, err := client.Do(req)
		if err != nil {
			continue
		}

		if resp.StatusCode == http.StatusTooManyRequests {
			blocked++
		}
		resp.Body.Close()
	}

	if blocked == 0 {
		t.Errorf("VULNERABLE: No rate limiting on API key attempts (%d attempts, 0 blocked)", attempts)
	} else {
		t.Logf("Brute force protection: %d/%d attempts blocked", blocked, attempts)
	}
}

// TestJWTManipulation tests JWT validation
func TestJWTManipulation(t *testing.T) {
	cfg := exploits.LoadConfig()

	// Various malformed/malicious JWTs
	maliciousJWTs := []string{
		// Algorithm confusion
		"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0.",
		// None algorithm
		"eyJhbGciOiJOT05FIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0.",
		// Empty signature
		"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.",
		// Malformed base64
		"not.a.jwt",
		"eyJhbGci.broken.token",
		// SQL injection in claims
		"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiInIE9SICcxJz0nMSJ9.xxx",
		// Very long JWT
		strings.Repeat("a", 10000),
	}

	client := &http.Client{Timeout: 5 * time.Second}

	for i, jwt := range maliciousJWTs {
		t.Run(truncate(jwt, 30), func(t *testing.T) {
			req, _ := http.NewRequest("GET", cfg.TargetURL+"/api/v1/events", nil)
			req.Header.Set("Authorization", "Bearer "+jwt)

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != http.StatusUnauthorized && resp.StatusCode != http.StatusForbidden {
				t.Errorf("VULNERABLE: Malicious JWT #%d accepted (status %d)", i, resp.StatusCode)
			}
		})
	}
}

// TestOrgIsolation tests cross-organization access
// NOTIF-008: Tenant isolation
func TestOrgIsolation(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	client := &http.Client{Timeout: 5 * time.Second}

	// Try to access resources with different org_id in path/params
	isolationTests := []struct {
		name   string
		path   string
		params string
	}{
		{"events_other_org", "/api/v1/events", "?org_id=other-org-id"},
		{"webhooks_other_org", "/api/v1/webhooks", "?org_id=other-org-id"},
		{"dlq_other_org", "/api/v1/dlq", "?org_id=other-org-id"},
	}

	for _, tc := range isolationTests {
		t.Run(tc.name, func(t *testing.T) {
			req, _ := http.NewRequest("GET", cfg.TargetURL+tc.path+tc.params, nil)
			req.Header.Set("Authorization", "Bearer "+cfg.APIKey)

			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			// Check if we got data from another org
			var result map[string]interface{}
			json.NewDecoder(resp.Body).Decode(&result)

			// If we got data and status is 200, check if isolation is broken
			if resp.StatusCode == http.StatusOK {
				if data, ok := result["data"].([]interface{}); ok && len(data) > 0 {
					t.Log("Received data - verify it belongs to authenticated org only")
				}
			}
		})
	}
}

// TestBootstrapEndpoint tests bootstrap endpoint exposure
// NOTIF-014: Bootstrap endpoint accessible without auth
func TestBootstrapEndpoint(t *testing.T) {
	cfg := exploits.LoadConfig()
	client := &http.Client{Timeout: 5 * time.Second}

	// Test status endpoint (should be protected or rate limited)
	req, _ := http.NewRequest("GET", cfg.TargetURL+"/api/v1/bootstrap/status", nil)
	resp, err := client.Do(req)
	if err != nil {
		t.Fatalf("Request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		var result map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&result)

		t.Logf("Bootstrap status exposed: %+v", result)

		// Check what info is leaked
		if authMode, ok := result["auth_mode"]; ok {
			t.Logf("INFO LEAK: auth_mode = %v", authMode)
		}
		if selfHosted, ok := result["self_hosted"]; ok {
			t.Logf("INFO LEAK: self_hosted = %v", selfHosted)
		}
	}

	// Test bootstrap endpoint without auth
	payload := map[string]interface{}{
		"email":    "attacker@evil.com",
		"password": "hacked123",
	}
	body, _ := json.Marshal(payload)

	req, _ = http.NewRequest("POST", cfg.TargetURL+"/api/v1/bootstrap", bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")

	resp, err = client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
		t.Error("CRITICAL: Bootstrap endpoint allows unauthenticated access to create admin!")
	}
}

func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max] + "..."
}
